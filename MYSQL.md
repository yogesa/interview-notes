# MySQL

## 基础

### 1.数据库的三大范式是什么？

- 第一范式：强调列是原子性，即数据表的每一列都是不可分割的原子数据项。
- 第二范式：要求实体的非主属性完全依赖于主关键字，所谓完全依赖是指不能存在仅依赖主关键字一部分的属性
- 第三范式：任何非主属性不依赖于其它非主属性

#### 2.MySQL支持哪些存储引擎

MySQL 支持多种存储引擎，比如 InnoDB，MyISAM，Memory，Archive, 大多数的情况下直接选择使用InnoDB 引擎都是合适的，InnoDB  也是MySQL 的默认存储引擎。

MyISAM 和 InnoDB 的区别有哪些？

- InnoDB 支持事务，MyISAM 不支持

- InnoDB 支持外键，而 MyISAM 不支持

- InnoDB 是聚集索引，数据文件是和索引绑在一起，必须要有主键，通过主键索引效率很高。

  MYISAM 是非聚集索引，数据文件是分离的，索引保存的是数据文件的指针，主键索引和辅助索引是独立的。

- InnoDB支持行级锁和表级锁，默认为行级锁。MyISAM 采用表级锁

- InnoDB不支持全文索引，而MYISAM 支持全文索引，查询效率上MyISAM要高

- InnoDB 不保存表的具体行数，MyISAM用一个变量保存了整个表的行数。

#### 3 . 超键 候选键 主键 分别是什么?

超键 : 在关系中能唯一表示元组的属性集称为关系模式的超键, 一个属性可以作为一个超键. (能区别确定一行数据唯一, 叫做超键)

候选键: 是最小超键, 即没有冗余元素的超键

主键: 数据库表中对储存数据对象予以唯一和完整标识的数据列或属性的组合, 一个数据列只能有一个主键, 且主键的取值不能缺失, 即不能为null

外键: 在一个表中存在另外一个表的主键称为此表的外键.

#### 4 .  SQL 约束有哪几种 ?

- NOT NULL : 用于控制字段的内容一定不能为空

- UNIQUE : 控制字段不能重复, 一个表允许有多个 Unique 约束
- PRIMARY KEY : 也是用于控制字段内容不能重复, 但它在一个表只允许出现一个.
- FOREIGN KEY : 用于预防破坏表之间连接的动作,  也能防止非法数据插入外键列, 因为它必须是指向的那个表中的值.
- CHECK ：用于控制字段的范围．

#### ５．MySQL 中的varchar 和 char 有什么区别 ?

- char 是一个定长字段, 加入申请了char (10) 空间, 无论实际存储多少内容, 该字段都占用10个字符, varchar() 是变长的, 申请的只是最大长度, 占用的空间为实际字符长度+1 , 最后一个字符使用了多长的空间.

- 在检索效率上来讲 , char > varchar , 因此在使用中, 如果确定某个字段值得长度, 可以使用char , 否则应该尽量使用 varchar , 例如存储用户MD5 加密后的密码, 则应该使用 char.

#### 6 . MySQL 中 in 和 exists 区别

- MySQL 中的 in 语句是<font color = "red"> 把外表和内表做 hash 连接</font>,  而 exists 语句是对外表做 loop 循环, 每次 loop 循环再对内表进行查询。

一直大家都认为 exits 比 in 语句的效率要高， 要区分情况的

- 如果两个表中一个较小， 一个较大，则子表查询表大的用exists ， 子表查询表小的用 in
- not in 和 not exists ， 如果查询语句使用了 not in ， 那么内外表都进行全表扫描，没有用到索引， 而 not extsts 的子查询依然能用到表上的索引，所以无论那个表大，用 not exists 都要 比 not in 要快。

#### 7 drop , delete 与 truncate 区别

三者都表示删除， 但是三者有一些差别

|          |                  Delete                   |            truncate            |                         drop                         |
| :------: | :---------------------------------------: | :----------------------------: | :--------------------------------------------------: |
|   类型   |                  属于DML                  |            属于DDL             |                       属于DDL                        |
|   回滚   |                  可回滚                   |            不可回滚            |                       不可回滚                       |
| 删除内容 | 表结构还在， 删除表的全部或者一部分数据行 | 表结构还在，删除表中的所有数据 | 从数据库中删除表，所有的数据行，索引和权限也会被删除 |
| 删除速度 |         删除速度慢，需要逐行删除          |           删除速度快           |                      删除速度快                      |

#### 8 什么是存储过程？ 存储过程有哪些优点？

存储过程是一些预编译的SQL语句

1 . 更加直白的理解，存储过程可以说是一个为了完成一组完成功能的SQL记录集，它是由一些 T-SQL 语句组成的代码块，这些 T-SQL 语句代码像一个方法一样，实现一些功能（对单表或多表的增删改查），然后再给这个代码块取一个名字，在用到这个功能的时候调用就行。

2 .  存储过程是一个预编译的代码块，执行效率比较高，一个存储过程替代大量T-SQL，可以降低网络通信量，提高通信速率，可以一定程度上确保数据安全。

#### 9 MySQL的执行流程

1 客户端通过TCP连接发送请求到 MySQL 连接器， 连接器会对该请求进行权限验证及连接资源的分配

2 查缓存，（但判断缓存是否命中时，MySQL 不会进行解析查询语句，而是直接使用SQL 语句和客户端发送过来的其它原始信息，空格 注解等都会导致缓存的不命中）

3 语法分析（SQL 语法是否写错， 如何把语句给预处理器，检查数据表和数据列是否存在，解析别名看是否存在歧义）

4 优化，是否使用索引，生成执行计划

5 交给执行器，将数据保存到结果集中，同时会逐步将数据缓存到查询缓存中，最终将结果返回给客户端。

更新语句执行会更复杂，需要检查表是否有排它锁，写 binlog ， 刷盘，是否执行commit

简单记住 ： 客户端 连接器 查缓存 SQL语法分析 优化器 执行器



## 事务

### 1 . 什么是数据库事务

- 事务是逻辑上的一组操作，要么都执行，要么都不执行。

- 事务是一个不可分割的数据库操作序列，数据并发控制的基本单位，其执行结果必须使数据库从一种一致性状态变到另一种一致性状态。

### 2. 事务具有四个特征

事务是一组原子性操作，这些操作要么全部发生，要么全部不发生，事务把数据库从一种一致性状态转换成另一种一致性状态。

- 原子性：事务是数据库的逻辑工作单位，事务中包含的各操作要么都做，要么都不做
- 一致性：事务执行的结果必须使数据库从一个一致性状态变到另一个一致性状态。如果事务的内的操作一次性全部提交，数据库就处于一致性状态。否则，当事务中的只完成部分操作，系统发生故障时，未完成的事务对数据所有的修改有一部分已经写入数据库，这时候数据库就处于一种不正确的状态，或者说不一致的状态。
- 隔离性：一个事务的执行不能其它事务干扰，即一个事务内部的操作及使用的数据对其它并发事务是隔离的，并发执行的各个事务之间不能相互干扰。
- 持久性：指一个事务一旦提交，它对数据库的数据的修改就应该是永久性的，接下来的任何操作或故障不应该对其执行结果有任何影响。

### 3  MySQL 的四种隔离级别

- Read uncommitted 读未提交
  
- 实际应用很少使用，性能不比其他级别好多少。读取未提交的数据，称为脏读，在该隔离级别，所有事务都可以看到其他未提交事务的执行结果。
  
- Read committed 读取提交内容

  - 这是大多数数据库系统的默认隔离级别，它满足了隔离的简单定义：一个事务只能看见已经提交事务所做的改变，这种隔离级别支持不可重复读，因为同一事务的其他实例在该实例处理期间可能会返回不同的结果。

- repeatable read 可重读

  - 这是 MySQL 的默认事务隔离级别，它确保<font color="red">同一事务的多个实例在并发读取数据时，会看到同样的数据行</font>
  - 可能会导致幻读，指查询的时候无记录，但 insert 记录时提示主键重复，类似于出现幻影，因而称之为幻读。

- serializable 可串行化

  - 通过强制事务排序，使之不可能相互冲突，从而解决幻读问题。简言之，它是在每个读的数据行上加上共享锁，在这个级别，可能导致大量的超时现象和锁竞争。

  | 隔离级别         | 脏读 | 不可重复读 | 幻影读 |
  | ---------------- | ---- | ---------- | ------ |
  | READ-UNCOMMITTED | √    | √          | √      |
  | READ-COMMITTED   | ×    | √          | √      |
  | REPEATABLE-READ  | ×    | ×          | √      |
  | SERIALIZABLE     | ×    | ×          | ×      |

  MySQL 默认采用的 REPEATABLE-READ 隔离级别，Oracle 默认采用的 READ_COMMITTED 隔离级别

## 4  事务隔离机制实现原理

事务隔离机制的实现基于锁机制和并发调度，其中并发调度使用的是 MVVC（多版本并发控制），通过保存修改的旧版本信息来支持并发一致性和回滚等特性

因为隔离级别越低，事务请求的锁越少，所以大部分数据库系统的隔离级别都是READ-COMMITED（读取提交内容），REPEATABLE-READ (可重读) ， 并不会有任何性能损失。

InnoDB 存储引擎在分布式事务的情况下一般会用到 SERIALIZABLE （可串行化）隔离级别。

## 5 什么是脏读？幻读？不可重复读？

- 这篇文章讲的好 ! https://cloud.tencent.com/developer/article/1450773
- 脏读： 事务A读取了事务B更新的数据，然后 B 回滚操作，那么A读取数据时脏数据
- 不可重复读：事务A 多次读取同一数据，事务B 在 事务A多次读取过程中，对数据做了更新并提交，导致事务A多次读取同一数据时，结果不一致。
- 幻读：当事务不是独立执行时发生的一种现象，当事务A对表中的数据进行了修改，比如这种修改**涉及到表中的全部数据行**，另外一个事务B此时插**入了一行新数据**，那么**事务A修改之后**，**发现还有一条数据没有修改**，就像发生了幻觉一样。
- 不可重复读侧重于修改，幻读侧重于新增或删除，脏读是一个事务读取了另一个发生回滚之前的数据。

## 6 事务的实现原理

- 事务是基于重做日志文件（redo log）和回滚日志（undo log）实现的
- 每提交一个事务必须先将该事务的所有日志写入到重做日志文件进行持久化，数据库就可以通过重做日志来保证事务的原子性和持久性。
- 每当有修改事务时，还会产生 undo log，如果需要回滚，则根据 undo log 的反向语句进行逻辑操作。比如 insert 一条记录就delete一条记录，undo log主要实现数据库的一致性。

## 7 MySQL 事务日志介绍下？

- innodb 事务日志包括 redo log 和 undo log

- undo log 指事务开始之前，在操作任何数据之前，首先将需操作的数据备份到一个地方

- redo log 指事务中操作的任何数据，将最新的数据备份到一个地方

- 事务日志的目的：实例或者介质失败，事务日志文件就派上用场。

## 8 redo log

redo log 不是随着事务的提交才写入，而是在事务的执行过程中，便开始写入 redo 中，具体的落盘策略可以进行配置，防止在发生故障的时间点，尚有脏页未写入磁盘，在重启 MySQL 服务的时候，根据 redo log 进行重做，从而达到事务的未入磁盘数据进行持久化这一特性，redo log 是为了实现事务的持久性而出现的产物。



## 9 undo log

undo log 用来回滚行记录到某个版本，事务未提交之前，undo 保存了未提交之前的版本数据，undo 中的数据可作为数据旧版本，快照供其它并发事务进行快照读，是为了实现事务的原子性而出现的产物，在 MySQL innodb 存储引擎中用来实现多版本并发控制。





## 索引

### 1.什么是索引?

索引是一个指向表行的指针, 能够快速检索符合where 条件的行, 并通过这些行检索出其它列值的数据结构.

### 2.索引有哪些优点？

优点：

​	1）可以大大加快数据的检索速度 ，

​	2）使用索引，在查询过程中，使用优化隐藏器，提升系统性能

缺点：

​	时间方面：创建索引和删除索引需要消耗时间，当对表中的数据进行增删改时，需要动态维护索引，会降低增删改的效率。

​	空间方面：索引需要占用物理空间

### 3. MySQL有哪几种索引类型

1.从存储结构上分为：

- Hash 索引
- B-Tree 索引

- full-index 全文索引 

- R-Tree 索引

2.从应用上分

- 主键索引 ： 创建表的时候，使用 对某字段用 primary key 修饰自动创建
- 普通索引 ：使用表的单列创建的索引

- 唯一索引：使用表的单列创建的索引，要求唯一，可以为空，null值只能包含一个

- 复合索引：使用多列创建的索引

聚簇索引：是数据的存储的一种存储方式，它的数据行只放在叶子节点中，内部节点不存放数据，B+TREE索引。

非聚簇索引：数据和索引分开存储，叶子节点指向了数据行。

### 4.说一说索引的底层实现

#### 4.1. Hash 索引

- 基于 Hash 表实现，当查询条件精确匹配 Hash 索引中的所有列时，才能够使用到 Hash 索引，不能是范围匹配和模糊匹配。
- 对于 Hash 索引的所有列，存储引擎都会为每一行计算一个 Hash 码，Hash 索引中存储的就是 Hash 码。
- 单条查询效率高，时间复杂度为 O(1) 。

#### 4.2 B - Tree 索引

B-Tree 能加快数据的访问速度，因为存储引擎不再需要进行全表扫描来获取数据，**数据分布在各个节点**之中。

#### 4.3  B + Tree 索引

- B-Tree 改进的版本，也是数据库索引所采用的存储结构。
- 数据分布在叶子节点之上，并且增加了顺序访问指针，每个叶子节点都指向相邻的叶子节点的地址。
- B+范围查询不需要遍历整个树，找到一个第一个数后，之后通过链表一样的方式遍历，B-数范围查找需要遍历整个树
- B-树每次查询一次就要进行一次 IO，但是如果树高 n，要找的元素恰好在叶子节点，那么最快也要 n 次 IO，相比于 B 树在相同数据的情况下，磁盘 IO 次数更少，效率也就更高。

B+树的性质：

- B+ 树有**两个头指针**，一个树的**根节点**一个是**最小关键码的叶节点**。
- 有 **k 个子树的中间节点包含 k 个元素**，每个中间节点只包含索引不包含数据以及最大或最小的键码。
- 所有的叶子节点中包含了全部元素的信息和指向这些元素记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接。
- B+ 树中，数据对象的插入和删除仅在叶节点上进行。

### 5. 为什么索引结构默认使用 B+tree, 而不是 B 树, Hash树 , 二叉树 , 红黑树

#### B+tree的优点:

##### 		IO 访问次数少

- 磁盘读写代价更低, B+树的内部节点并没有指向关键字具体信息的指针,  因此其内部节点相对B树更小,  如果把所有中间内部节点的关键字存放在同一盘块中, 那么盘块容纳的关键字数量也越多, 一次性读入内存的需要查找的关键字也就越多, 相对IO读写次数就能降低了。

  ##### 适合区间查询

- B+ 树的数据都存储在叶子节点中, 分支结点均为索引, 方便扫库, 只需要扫一遍叶子节点即可, 但是 B 树因为分支节点同样存储着数据, 我们要找到具体的数据, 需要进行一次中序遍历按序来扫, 所以B+树更适合区间查询, 所以使用B+树用于索引.

hash :

- 虽然可以快速定位, 但是没有顺序, IO 复杂度高
- 基于Hash 表实现,  只有<font color="red">memory 存储引擎</font>支持hash索引
- 适合等值查询, 如 = , in() , <=> , 并且查询时非常快, 不支持范围查询
- 因为不是按照索引值顺序存储的 , 就不能像 B+ tree 索引一样利用索引完成排序
- 因为Hash 索引始终索引所有列的全部内容, 所以不支持部分索引的匹配查找
- 如果有大量重复键值的情况下, 哈希索引的效率会很低, 因为存储哈希冲突的问题.

二叉树 :

树的高度不均匀, 不能自平衡, 查找效率跟数据有关(树的高度), 并且 IO 代价高.

<font color="red">红黑树</font>: 树的高度随着数据量增加而增加, IO 代价高.

#### 6. 聚簇索引 和 非聚簇索引

聚簇索引 : 索引与数据存储在一块, 比如 B+tree 的叶子节点的存储了整行数据的主键索引, 也被称之聚簇索引.

非聚簇索引(二级索引): 索引和数据不放在一块, 比如MyISAM 的叶节点仍然是索引节点, 只不过有一个指针指向对应的数据块.

#### 区别:  存储 与 查询次数

- 区别在于非聚簇索引的叶子节点不存储表中的数据, 而是存储该列对应的主键(行号) . 聚簇索引的叶子节点存储数据.

- 聚簇索引查询只会查询一次即可, 而非主键索引需要回表查询多次 , 当然如果是覆盖索引 , 查询一次即可. 

#### 7 回表查询

![image-20220414150425770](C:\Users\hui\AppData\Roaming\Typora\typora-user-images\image-20220414150425770.png)



- 因为InnoDB普通索引的叶子节点存储的是主键值, 而InnoDB聚集索引的叶子节点存储行记录.

  例如下列 查询 ```select * from t where name = "lisi";```

  使用普通索引查询时, 先要通过普通索引定位到主键值5

  再通过主键去聚集索引定位到行记录. 这就是所谓的回表查询, 先定位主键值 , 再定位行记录, 他的性能较扫一遍索引树更低.

#### 8 覆盖索引

若 ```select```后面查询的字段都可以从这个索引的树中获取, 这种情况下一般可以说是用到了覆盖索引.也就是查询的字段被所用的索引树全部覆盖到.

通过索引值可以直接找到要查询的字段的值, 而不需要通过主键值回表查询,那么叫做覆盖索引

比如

```mysql
create index idx_name_age ON user(name,age);
```

查询名称为 lihua 的年龄:

```mysql
select name,age from user where name = "lihua";
```

查找的字段 name 和 age 都包含在联合索引 idx_name_age 的索引树中, 这样的查询就是覆盖索引查询.

#### 9 非聚簇索引一定会回表查询吗?

不会, 比如覆盖索引, 如果查询语句要求的字段命中了索引, 一次就查询到, 就不需要回表查询了.

#### 10 联合索引是什么 ? 为什么需要注意联合索引中的顺序 ?

MySQL 可以使用多个字段同时建立一个索引, 叫做联合索引, 在联合索引中, 如果想要命中索引, 需要按照建立索引的字段顺序挨个使用, 否则无法命中索引. 

#### 具体原因:

MySQL 使用索引时需要索引有序, 比如建立了 ```name, age , school```的联合索引, 那么索引的排序为: 先按照 name 排序, 如果name相同, 则按照 age 排序, 如果 age 的值也相等, 则按照 school 进行排序.

联合索引进行查询时, 此时仅仅按照name严格有序 , 因此必须首先使用 name 字段进行等值查询, 之后对于匹配到的列 而言, 其按照age字段严格有序, 此时使用age字段用所索引查找, 依此类推, 因此在建立联合索引的时候应该注意索引列的顺序, 一般情况下, 将查询需求频繁或者字段选择性高的列放在前面, 也可以根据特例查询或者表结构进行单独调整.

#### 11 MySQL 最左前缀原则 ?

最左前缀原则就是最左优先, 在创建多列索引时, 要根据业务需求, where 子句中使用最频繁的一列放在最左边. 

mysql 会一直向右匹配直到遇到范围查询(>, <, between,like) , 就停止匹配, 比如 a = 1 and b = 2 and c > 3 and d = 4, 如果建立(a,b,c,d)索引, d 是用不到索引的, 如果建立(a,b,d,c)索引, 则都可以使用到.

= 和 in 可以乱序, 比如 and = 1 and b = 2 and c = 3 建立索引(a,b,c)可以任意顺序, mysql 的查询优化器都会帮你优化成索引可以识别的形式.

#### 12 前缀索引 ? 

前缀索引也叫局部索引, 指当索引字段非常长, 既占内存空间, 也不利于维护, 比如给身份证前10位添加索引, 这样有助于不占内存空间, 有利于维护. order by 不支持前缀索引.

当数据前几个字符在之前就开始不同, 适合使用前缀索引.

#### 13 索引下推

索引下推优化(index Condition PushDown) 是mysql 5.6 添加的 , 用于优化数据查询.

- 索引下推优化技术，可以减少存储引擎查询基础表的次数，也可以减少MySQL服务器从存储引擎接收数据的次数。

- 当使用索引条件下推优化时，如果存在某些被索引的列的判断条件时，MySQL服务器将这部分判断条件传递给存储引擎，然后存储引擎通过判断索引是否符合MySQL服务器传递的条件，只有当索引符合条件时，才会将数据检索出来返回给MYSQL服务器。

  **简单来说就是将判断条件从MySQL服务器推送到存储引擎，存储引擎在查询后立即判断是否符合条件， 不用返回到MySQL服务器再进行判断。**

#### 14 怎么查看MySQL语句有没有用到索引？

用 explain 对查询语句分析就ok了。

key：字段MySQL在当前查询时所真正使用到的索引。

possible_key: 查询中可能用到的索引。

#### 15 为什么官方建议使用自增长主键作为索引

结合 B+tree 树的特点，自增主键是连续的，在插入过程中尽量减少页分裂，即使要进行也分裂，也只会分裂很少一部分，并且减少数据的移动，每次插入都是插入到最后，总之就是减少分裂和移动的频率。

#### 16 如何创建索引

三种方式 创建表的方式

- 创建表的时 使用 KEY 关键字

```mysql
Create table user_table (
	id int auto_increment primary key,
    first_name varchar(16),
    last_name varchar(16),
    information text,
    KEY name (first_name, last_name),
    FULLTEXT KEY (information),
    UNIQUE KEY (id_card)
)
```

- 使用 alter table 命令去增加索引

  ```mysql
  ALTER TABLE table_name ADD INDEX index_name (column_list)
  ```

column_list 指出对哪些列进行索引， 多列时用逗号分隔。

- 使用create index 命令创建

```mysql
create index index_name on table_name(colimn_list);
```

#### 17 创建索引时需要注意什么？

- 非空字段：应该指定列为 NOT NULL，除非你想存储 NULL，在 mysql 中，含有空值的列很难进行查询优化，因为它使得索引、索引的统计信息以及比较运算更加复杂。最好可以用0，一个特殊的指或者空串代替空值。
- 取值离散值大的字段：将取值差异程度较大的列放在联合索引前面，可以通过count()查看字段的差异值，<font color="red">返回值越大说明字段的唯一值越多字段的离散程度高。</font>
- 索引字段越小越好 : 数据库的数据存储以页为单位，一页存储的数据越多，一次IO操作获取的数据越大效率越高。

#### 18 建索引的原则有哪些?

- 最长匹配原则, mysql 会一直向右匹配直到遇到范围查询(> < between) 就体制匹配 。所以可以根据 查询的条件， 可以适当调整联合索引的列的位置 ，比如 a == 1 and b ==2 and c > 3 and d == 4 , 可以建立索引 a b c d， 那么索引 d 用不到 ，而 建立 索引 a b d c 索引 都可以用到。

- = 和 in 可以乱序， 比如 a == 1 and b == 2 and c ==3 建立(abc)索引可以任意顺序，mysql 的查询优化器会帮你优化成索引可以识别的形式

- 尽量选择区分度高的列作为索引，区分度的公式是 count(distinct col) / count(*) , 表示字段不重复的比例， 比例越大我们扫描的记录数越少，唯一键的区分度是1，而一些状态，性别字段可能在大数据面前区分度就是 0。

- 索引列不能参与计算，保持列 “干净”，比如 from_unixtime(create_time)='2014-05-29', 就不能使用到索引，原因很简单，b+树中寸的都是数据表中的字段值，但是进行检索时，需要把所有元素都应用函数才能比较，显然成本太大。所以语句应该写成 create_time = unix_timestamp('2014-05-29'),.

- 尽量的扩展索引，不要新建索引，比如表中已有a的索引，现在要建立 (a,b) 索引，那么只需要修改原来的索引即可。

  #### 19 使用索引查询一定能提高查询的性能吗？

- 通常通过索引查询数据比全表扫描要快，但是也要注意到它的代价。

- 索引需要空间来存储，也需要定期维护，每当有记录在表中增减或索引列被修改时，索引本身也会被修改，这意味着每条记录的 Insert ， delete ，update 将为此多付出4，5次的磁盘I/O，因为索引需要额外的存储空间和处理，那些不必要的索引反而会使查询反应时间变慢，使用索引查询不一定能提高查询性能，

- 索引范围查询（INDEX RANGE SCAN）适用于两种情况：

  - 基于一个范围的检索，一般查询返回结果集小于表中记录数 30%
  - 基于非唯一索引的检索

  #### 20 什么时候索引失效

- 使用 != , 或者 < ，> 导致索引失效

- 类型不一致导致的索引失效

- 函数导致的索引失效

  ```mysql
  SELECT * FROM user WHERE DATE(create_time) = '2020-09-03';
  ```

  索引列在函数内，失效

- 运算符导致索引失效

  ```mysql
  SELECT * FROM user where age - 1 = 21;
  ```

  如果对列进行了（+，-，*，/,! ）,那么都将不会走索引

- OR 引起的索引失效

  ```mysql
  SELECT * FROM user where name = '张三' OR height = '175'
  ```

  OR 导致索引失效，OR若连接的是同一个字段不会失效，反之就会失效

- 模糊搜索导致的索引失效

  ```mysql
  select * from user where name like ‘%冰’;
  ```

- NOT IN ， NOT EXISTS 导致索引失效