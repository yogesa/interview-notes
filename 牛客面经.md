



###请你讲一讲单例模式,请你手写一下单例模式

#### 饿汉式单例模式

优点: 

缺点: 

#### 懒汉式单例模式

优点: 

缺点: 

安全懒汉式单例模式

双重检验锁单例模式

内部类单例模式(饿汉式)

### 请你说说虚拟内存和物理内存的区别

1 物理内存 以前, 还没有虚拟内存概念的时候,程序寻址用的都是物理地址。程序能寻址的范围是有限的,这取决于 CPU 的地址线条数。比如在 32 位平台下,寻址的范围是 2^32 也就是 4G。并且这是固定的, 如果没有虚拟内存, 且每次开启一个进程都给 4G 物理内存,就可能会出现很多问题：

- 因为物理内存是有限的, 当有多个进程要执行的时候, 都要给 4G 内存, 很显然内存不够,这很快就分配完了,于是没有得到分配资源的进程就只能等待。当一个进程执行完了以后,再将等待的进程装入内存。这种频繁的装入内存的操作效率很低 
-  由于指令都是直接访问物理内存的,那么任何进程都可以修改其他进程的数据,甚至会修改内核地址空间的数据,这是不安全的

2 虚拟内存 由于物理内存有很多问题,所以出现了虚拟内存。虚拟内存是计算机系统内存管理的一种技术。它使得应用程序认为它拥有连续的可用的内存（一个连续完整的地址空间）,而实际上,它通常是被分隔成多个物理内存碎片,还有部分暂时存储在外部磁盘存储器上,在需要时进行数据交换。

### 请你说说IO多路复用

I/O 多路复用是一种使得程序能同时监听多个文件描述符的技术,从而提高程序的性能。I/O 多路复用能够在单个线程中,通过监视多个 I/O 流的状态来同时管理多个 I/O 流,一旦检测到某个文件描述符上我们关心的事件发生（就绪）,能够通知程序进行相应的处理(读写操作) Linux 下实现 I/O 复用的系统调用主要有 select、poll 和 epoll。

#### select

>select 的主旨思想： 
>
>- 首先要构造一个关于文件描述符的列表,将要监听的文件描述符添加到该列表中,这个文件描述符的列表数据类型为 fd_set,它是一个整型数组,总共是 1024 个比特位,每一个比特位代表一个文件描述符的状态。比如当需要 select 检测时,这一位为 0 就表示不检测对应的文件描述符的事件,为 1 表示检测对应的文件描述符的事件。
>
>- 调用 select() 系统调用,监听该列表中的文件描述符的事件,这个函数是阻塞的,直到这些描述符中的一个或者多个进行 I/O 操作时,该函数才返回,并修改文件描述符的列表中对应的值,0 表示没有检测到该事件,1 表示检测到该事件。函数对文件描述符的检测的操作是由内核完成的。 - select() 返回时,会告诉进程有多少描述符要进行 I/O 操作,接下来遍历文件描述符的列表进行 I/O 操
>
>select 的缺点： 
>
>- 1. 每次调用select,都需要把 fd 集合从用户态拷贝到内核态,这个开销在 fd 很多时会很大；
>  2. 同时每次调用 select 都需要在内核遍历传递进来的所有 fd,这个开销在 fd 很多时也很大；
>  3. select 支持的文件描述符数量太小了,默认是 1024（由 fd_set 决定）；
>  4. 文件描述符集合不能重用,因为内核每次检测到事件都会修改,所以每次都需要重置； 
>  5. 每次 select 返回后,只能知道有几个 fd 发生了事件,但是具体哪几个还需要遍历文件描述符集合进一步判断。

#### poll

> poll 的原理和 select 类似, poll 支持的文件描述符没有限制。

#### epoll

> epoll 是一种更加高效的 IO 复用技术,epoll 的使用步骤及原理如下：
>
> - 调用 epoll_create() 会在内核中创建一个 eventpoll 结构体数据, 称之为 epoll 对象,在这个结构体中有 2 个比较重要的数据成员,一个是需要检测的文件描述符的信息 struct_root rbr（红黑树）,还有一个是就绪列表struct list_head rdlist,存放检测到数据发送改变的文件描述符信息（双向链表）
> - 调用 epoll_ctrl() 可以向 epoll 对象中添加、删除、修改要监听的文件描述符及事件；
> - 调用 epoll_wt() 可以让内核去检测就绪的事件,并将就绪的事件放到就绪列表中并返回,通过返回的事件数组做进一步的事件处理
>
> 两种工作模式
>
> - LT 模式（水平触发）
>   -  LT（Level - Triggered）是缺省的工作方式,并且同时支持 Block 和 Nonblock Socket。在这种做法中,内核检测到一个文件描述符就绪了,然后可以对这个就绪的 fd 进行 IO 操作,如果不作任何操作,内核还是会继续通知。
> -  ET 模式（边沿触发）
>   -  ET（Edge - Triggered）是高速工作方式,只支持 Nonblock socket。在这种模式下,当描述符从未就绪变为就绪时,内核通过 epoll 检测到。然后它会假设你知道文件描述符已经就绪,并且不会再为那个文件描述符发送更多的就绪通知,直到你做了某些操作导致那个文件描述符不再为就绪状态了。
>   - 注意 : 
>     - 如果一直不对这个 fd 进行 IO 操作（从而导致它再次变成未就绪）,内核不会发送更多的通知（only once）。 ET 模式在很大程度上减少了 epoll 事件被重复触发的次数,因此效率要比 LT 模式高。epoll 工作在 ET 模式的时候,必须使用非阻塞套接口,以避免由于一个文件描述符的阻塞读/阻塞写操作把处理多个文件描述符的任务饿死。

### 请你说说线程和协程的区别

1 线程是操作系统的资源,线程的创建、切换、停止等都非常消耗资源,而创建协程不需要调用操作系统的功能,编程语言自身就能完成,所以协程也被称为用户态线程,协程比线程轻量很多；

2 线程在多核环境下是能做到真正意义上的并行,而协程是为并发而产生的；

3 一个具有多个线程的程序可以同时运行几个线程,而协同程序却需要彼此协作的运行；

4 线程进程都是同步机制,而协程则是异步

5 线程是抢占式,而协程是非抢占式的,所以需要用户自己释放使用权来切换到其他协程,因此同一时间其实只有一个协程拥有运行权,相当于单线程的能力； 

6 操作系统对于线程开辟数量限制在千的级别,而协程可以达到上万的级别。

### 请说说你对反射的了解

要点 : 需要反射的原因  反射可以实现的操作, 反射的应用场景

程序在运行时可能会收到外部传入的对象, 该方法在编译时类型为 Object, 但程序有需要调用该对象的运行时类型方法. 为了解决这个问题,程序需要在运行时发现对象和类的真实信息. 然而 , 如果编译时根本无法预知对象和类属于哪些类, 程序只能依靠运行时信息来发现该对象和类的真实信息, 此时就必须使用到反射了.

可以通过反射实现如下操作:

- 程序运行时, 可以通过反射获得任意一个类的Class对象, 并通过这个对象查看这个类的信息
- 程序运行时, 可以通过反射创建任意一个类的实例, 并访问该实例的成员;
- 程序运行时, 可以通过反射机制生成一个类的动态代理类或动态代理对象

反射的应用场景:

- 使用JDBC时, 如果创建数据库的连接, 需要通过反射加载数据库的驱动程序
- 多数框架支持注解和XML配置,从配置中解析出来的类是字符串, 需要利用反射机制实例化
- 面向切面编程(AOP)的实现方案, 程序运行时创建的目标对象的代理类需要通过反射来实现Q

### 请你说说 ArrayList 和 LinkedList 的区别

底层实现, 数据和双向链表  是否支持随机访问和事件复杂度 插入删除  占用内存

1 底层实现ArrayList是数组, LinkedList 底层是双向链表

2 ArrayList 支持通过索引下标随机访问, 时间复杂度O(1) , LinkedList 不支持随机访问, 访问需要遍历链表 ,时间复杂度O(n)

3 删除和插入场景下, LinkedList 更好, 因为时间复杂度为O(1) , 而ArrayList平均复杂度为n(n)

4 LinkedList 占用存储空间更多, 处理存储数据 ,还要存储指向前后节点的引用

