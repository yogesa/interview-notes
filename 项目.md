### 为什么要使用 mqtt 中间件?

**选择mqtt的背景 :** 

传统的消息中间件, 例如 RocketMQ, RabbitMQ, Kafka 都是面向微服务大数据领域, 负责消息的存储和转发, 消息的生产者和消费者都是服务端应用. 而移动互联网和Iot领域有所不同, 物联网设备一般是一种资源有限的设备, iot场景更侧重于多语言多平台的海量设备接入, 消息的生产和消费过程很明确, 所以传统的消息中间件不适合这些领域. 所以最终技术选型选择了mqtt.

**项目中mqtt的作用**

1.解除边缘网关与云平台的耦合度

解耦物联网设备与云端, 边缘网关汇聚数据有多个用途, 一是云端应用进行显示,二是在云端进行持久化, 三是一些关键数据进行区块链存储, 可能后面还有子系统, 扩展,  所以如果边缘网关降所有的这些模块整合在一起, 后面修改, 或者扩充作用, 又需要修改代码, 就很麻烦, 所以,为了使物联网设备与云端进行解耦合, 引入了mqtt中间件, 实现云端应用与物联网端解耦. 

2.削处高峰时期的数据

因为有些数据需要存储至mysql中，到1s内突然采集到大量数据时，那么系统数据并发处理数量可能增加到几千条，会给mqsql数据库带来很大的压力, 使用消息队列，将突然到来的大并发数据写入消息队列，而数据库和云平台, 云平台作为消费者, 只需要以一个固定的速率拉取消息队列中的请求，可以避免哪怕是高峰期, 云平台也不会挂掉.

### mqtt 中间件与其它中间件的区别 ?

mqtt 是物联网应用的一种:轻量级"的通讯协议, 非常适合设备多, 每个设备发送数据较小的应用场景, 因为移动端场景一般都具备海量设备, 单设备数据较少的特点, 所以物联网应用中使用MQTT非常合适.

RockerMQ , 面向服务端的消息引擎, 主要用于服务组件之间的解耦, 异步通知, 削峰等, 服务器规模小,但需要大量的消息处理,吞吐量要求高, 吞吐量要求高. 因此, 消息队列RocketMq 适用于服务端进行大批量的数据处理和分析场景

移动端设备上使用微消息队列MQTT, 服务端应用中则使用消息队列 RockerMq 

MQTT与RockerMq对比

| 功能特性       | 微消息队列MQTT                               | 消息队列RocketMQ                   | 消息队RabbitMq                                              |
| -------------- | -------------------------------------------- | ---------------------------------- | ----------------------------------------------------------- |
| 客户端的连接数 | 客户端规模庞大, 百万甚至千万级               | 一般服务器规模较少, 很少数万台设备 |                                                             |
| 单客户端消息量 | 单个客户端需要处理的消息少, 一般定时收发消息 | 单个客户端处理消息量大,注重吞吐量  |                                                             |
| 部署场景       | 移动设备, App软件 ,H5页面等                  | 服务端应用                         | RabbitMQ 最初起源于金融系统，用于在分布式系统中存储转发消息 |
| 选择原则       | 对于部署在移动端,App 或浏览器等平台的应用    | 对于部署在服务器的应用             | 分布式                                                      |

RabbitMq 特点 : 高可靠性(持久化, 传输确认, 发布确认) , 高可用性(在集群机器上设置镜像), 支持多种协议(AMQP,STOMP, MQTT)

#### MQTT 特性

(1) 使用发布/订阅消息模式, 提供一对多的消息发布, 解除应用程序耦合

(2) 不关注于负载内容, 对负载内容屏蔽的消息传输

(3) 使用TCP/IP提供的网络连接

(4) 有三种消息发布服务质量

QoS = 0	"至多一次" 应为传感器数,丢失一次无所谓, 因为不久之后还会有第二次发送, 这一种方式主要是普通App的推送, 

QoS = 1	"至少一次" 确保消息到达, 但消息重复可能会发生

QoS = 2    "只有一次" 确保消息到达一次 ,应用在要求比较严格的计费系统中, 计费系统消息重复或丢失会导致不正确的结果

(5) 小型传输, 开销很小, 所以说为什么非常适合在物联网领域, 传感器与服务器的通信, 信息的收集



###为什么要用 disruptor 并发框架 ?

disruptor 是什么 ? 

disruptor 一个高性能队列, 不同于其它消息队列, 它是一个系统内部的内存队列,基于Disruptor开发的单线程每秒可以处理 600 万订单 

为什么使用 ?

因为考虑到, 边缘网关可能会接入大量的传感器节点可能有几千个, 为了提高边缘网关的并发处理能力, 提高边缘网关的性能, 引入disruptor并发框架. 

disruptor 为什么高性能 ?

1 disruptor 的 RingBuffer 可以做到完全无锁, 也是因为"单线程写", 这是所有的"前提的前提", 离开了这个前提条件, 没有任何技术可以做到完全无锁. 

2 系统内存优化 , 使用内存屏障, 也就是volatile 和 happen before 原则

3 系统缓存优化- 消除伪共享

缓存系统中是以缓存行(cache line)为单位存储的,缓存行是2的整数幂的连续字节, 一般为32-256个字节.最常见的缓存行大小是64个字节

当多线程修改互相独立的变量时 , 如果这些变量共享一个缓存行, 就会无意中影响彼此的性能, 这就是伪共享 

4 算法优化 - 使用序号栅栏机制

序号栅栏SequenceBarrier和序号Sequence搭配使用, 协调管理消费者和生产者的工作速度, 避免了锁和CAS的使用

- 消费者序号数值必须小于生产者序号数值
- 消费者序号数值必须小于其前置消费者的序号数值
- 生产者序号数值不能大于消费者中最小的序号数值

具体是怎么实现的 ? 

event  --> 通过 EventTranslatorOneArg 类中的translateTo将sourceEventModel(源事件模型)转化为TargetEventModel(目标事件模型)

然后让 ringBuffer 调用 publishEvent 存储到ringbuffer中

###为什么要用线程池 ?



### 为什么要用数据库连接池 ?



### 线程池与数据库连接池有什么区别?



###什么是事件驱动模型?



### 出现过什么问题?TCP粘包问题?怎么解决的?



### 为什么要使用多态实现多协议解析?



### mqtt协议的几个参数, 相关的东西?



###日志模块是怎么实现的?



###管理工具的使用git版本管理工具的使用 ?



### 压力测试是怎么做的?



### 遇到过的问题 ?

#### 数据粘包

1. 由于是物理设备，偶尔会产生无效，获得不完整的数据，导致解析就会出问题，在应用层做校验。

1. 融合异构网络的区块链溯源边缘网关

1. 串口来的数据太快, 网关来不及处理, 就会导致网关出现卡顿的现象 

// 解决办法: 设置缓冲区, 解决上传速度与处理速度不匹配问题.

### 有没有使用什么设计模式 ?

在创建 disruptor 消息的时候使用了工厂模式创建对象, 工厂模式的优点

- 面向接口编程，体现了面向对象的思想；
- 将创建对象的工作转移到了工厂类；

​	 

