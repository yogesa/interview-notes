### 为什么要使用 mqtt 中间件?

**选择 MQTT 的背景 **

​		传统的消息中间件, 例如 `RocketMQ`, `RabbitMQ`, `Kafka` 都是面向微服务大数据领域, 负责消息的存储和转发, 消息的生产者和消费者都是服务端应用. 而移动互联网和`Iot`领域有所不同, 物联网设备一般是一种资源有限的设备, `iot` 场景更侧重于多语言多平台的海量设备接入, 消息的生产和消费过程很明确, 所以传统的消息中间件不适合这些领域. 所以最终技术选型选择了 `mqtt`.

**项目中 MQTT 的作用**

1 解除边缘网关与云平台的耦合度

解耦物联网设备与云端, 边缘网关汇聚数据有多个用途, 一是云端应用进行显示, 二是在云端进行持久化, 三是一些关键数据进行区块链存储, 可能后面还有子系统, 扩展,  所以如果边缘网关将所有的这些模块整合在一起, 后面如果需要修改, 或者扩充，又需要修改代码, 就很麻烦, 所以,为了使物联网设备与云端进行解耦合, 引入了mqtt中间件, 实现云端应用与物联网端解耦。

2 削处高峰时期的数据

因为有些数据需要存储至 mysql 中，到 1s 内突然采集到大量数据时，那么系统数据并发处理数量可能增加到几千条，会给mysql数据库带来很大的压力, 使用消息队列，将突然到来的大并发数据写入消息队列，而数据库和云平台, 云平台作为消费者, 只需要以一个固定的速率拉取消息队列中的请求，可以避免哪怕是高峰期, 云平台也不会挂掉.

### MQTT 中间件与其它中间件的区别 ?

MQTT 是物联网应用的一种: 轻量级"的通讯协议, 表现在两点发送的数据量小，要求接入的设备多，海量的设备可能几千或者几万。所以物联网中使用 MQTT 中间件很合适。

RockerMQ , 面向服务端的消息引擎, 主要用于服务组件之间的解耦, 异步通知,  削峰等,  服务器数量规模小,  但需要大量的消息处理,要求 吞吐量要求高。 因此,  消息队列 RocketMq 适用于服务端进行大批量的数据处理和分析场景

移动端设备上使用微消息队列MQTT, 服务端应用中则使用消息队列 RockerMq 

MQTT 与 RockerMq 对比

| 功能特性       | 微消息队列MQTT                               | 消息队列RocketMQ                   | 消息队RabbitMq                                              |
| -------------- | -------------------------------------------- | ---------------------------------- | ----------------------------------------------------------- |
| 客户端的连接数 | 客户端规模庞大, 百万甚至千万级               | 一般服务器规模较少, 很少数万台设备 |                                                             |
| 单客户端消息量 | 单个客户端需要处理的消息少, 一般定时收发消息 | 单个客户端处理消息量大,注重吞吐量  |                                                             |
| 部署场景       | 移动设备, App软件 ,H5页面等                  | 服务端应用                         | RabbitMQ 最初起源于金融系统，用于在分布式系统中存储转发消息 |
| 选择原则       | 对于部署在移动端,App 或浏览器等平台的应用    | 对于部署在服务器的应用             | 分布式                                                      |

RabbitMq 特点 : 高可靠性(持久化, 传输确认, 发布确认) , 高可用性(在集群机器上设置镜像), 支持多种协议(AMQP,STOMP, MQTT)

#### mqtt 特性

(1) 使用发布/订阅消息模式, 提供一对多的消息发布, 解除应用程序耦合

(2) 不关注于负载内容, 对负载内容屏蔽的消息传输

(3) 使用TCP/IP提供的网络连接

(4) 有三种消息发布服务质量

QoS = 0	"至多一次" 应为传感器数据,丢失一次无所谓, 因为不久之后还会有第二次发送, 这一种方式主要是普通App的推送, 

QoS = 1	"至少一次" 确保消息到达, 但消息重复可能会发生

QoS = 2    "只有一次" 确保消息到达一次 ,应用在要求比较严格的计费系统中, 计费系统消息重复或丢失会导致不正确的结果

(5) 小型传输, 开销很小, 所以说为什么非常适合在物联网领域, 传感器与服务器的通信, 信息的收集

###为什么要用 Disruptor 并发框架 ?

disruptor 是什么 ? 

disruptor 一个高性能队列, 不同于其它消息队列, 它是一个系统内部的内存队列,基于Disruptor开发的单线程每秒可以处理 600 万订单 

为什么使用 ?

因为考虑到, 边缘网关可能会接入大量的传感器节点可能有几千个, 为了提高边缘网关的并发处理能力, 提高边缘网关的性能, 引入disruptor并发框架. 

disruptor 为什么高性能 ?

1 disruptor 的 RingBuffer 队列是通过完全无锁实现的。

2 系统内存优化 , 使用内存屏障, 也就是volatile 和 happen before 原则。

3 通过消除伪共享，来实现系统缓存优化

缓存系统中是以缓存行(cache line)为单位存储的,缓存行是2的整数幂的连续字节, 一般为32-256个字节.最常见的缓存行大小是64个字节disruptor 定义的变量占用一个缓存行，因为当多线程修改互相独立的变量时 , 如果这些变量共享一个缓存行, 就会无意中影响彼此的性能, 这就是伪共享 。

4 算法优化 - 使用序号栅栏机制

序号栅栏SequenceBarrier和序号Sequence搭配使用, 协调管理消费者和生产者的工作速度, 避免了锁和CAS的使用

- 消费者序号数值必须小于生产者序号数值。
- 消费者序号数值必须小于其前置消费者的序号数值。
- 生产者序号数值不能大于消费者中最小的序号数值。

具体是怎么实现的 ? 

串口获取事件驱动模型监测到来时候数据, 立马从串口流中读取数据, 通过两个不同协议的解析器解析不同协议的数据, 然后存储 event 消息 --> 通过 EventTranslatorOneArg  类中的 translateTo 将 sourceEventModel (源事件模型)转化为 TargetEventModel  (目标事件模型),  然后让 ringBuffer 调用 publishEvent 存储到 ringbuffer 中,  disruptor 消费者监听到消息, 立马取出数据, 然后分别用于三个方面的使用. 一个方面就是, 暂存在网关测试, 第二个是发布到消息中间件上, 第三个用于将一个重要的数据, 存储至区块链中, 因为区块链具有存储后不易篡改的特性, 保证重要的数据存储后不被修改.

###为什么要用线程池 ?

不用线程池，当客户端来一个新的连接时，就创建一个线程来工作，能够使代码很简单，但是当该系统投入使用，出现每秒并发超过100个请求时，那么势必消耗巨大的CPU时间和内存资源。系统就需要投入巨大的时间在线程创建和销毁上，如果使用连接池，就会减少这部分的投入，系统就会专注于实际的商业应用。

优点 ：

降低资源消耗, 通过重复利用已创建的线程降低线程创建和销毁造成的消耗

提高响应速度, 任务不需要等到线程创建就能立即执行

提高线程的可管理性, 线程是稀缺资源, 如果无限制的创建, 不仅消耗系统资源, 还会降低系统的稳定性, 使用线程池可以进行统一的分配, 	调优和监控

### 为什么要用数据库连接池 ?

对于简单的数据库应用, 对于数据库访问不是很频繁, 这时可以简单地需要访问数据库时, 就创建一个连接, 用完后就关闭它. 但是频繁访问数据库的时候, 频繁创建和销毁连接对象消耗系统资源 , 而使用连接池, 可以将项目创建连接对象保存在池中待用, 每次访问时从池中获取已经存在的连接, 使用完毕后, 再返回池中, 从而减少了创建连接和销毁连接而浪费的系统资源。

1 连接池的优点 ： 资源重用 

​		由于数据库连接得到重用，**避免了频繁创建、释放连接引起的大量性能开销**。在减少系统消耗的基础上，另一方面也增进了系统运行环境的平稳性（减少内存碎片以及数据库临时进程/线程的数量）。

2 更快的响应速度

​		数据库连接池在初始化过程中，往往已经创建了若干数据库连接置于池中备用。此时连接的初始化工作均已完成。对于业务请求处理而言，**直接利用现有可用连接，避免了数据库连接初始化和释放过程的时间开销**，从而缩减了系统整体响应时间。

3 统一的连接管理，避免数据库连接泄漏

​		在较为完备的数据库连接池实现中，可根据预先的连接占用超时设定，强制收回被占用连接。从而避免了常规数据库连接操作中可能出现的资源泄漏。

### 线程池与数据库连接池有什么区别?

#### 区别 ：

连接池 ： 

- 连接池是面向数据库连接的
- 连接池是为了优化数据库连接资源的
- 连接池优点类似于在客户端做优化

线程池：

- 线程池是面向后台程序的
- 线程池是为了提高内存和CPU效率
- 线程池类似于在服务端做优化

#### 共同点 ：

都是为了提高系统的性能和效率

###什么是事件驱动模型?

当系统的监听器监听到事件源到来的时候，执行响应的处理过程，称之为事件驱动模型。

事件驱动模型三大要素 ： 

事件源：能够接收到外部事件的源体；

侦听器：能够接收到事件源通知的对象；

事件处理程序：用于处理事件的对象；

编程过程 ： 

1 系统启动，监听器把自己注册到事件中心，与某种事件进行绑定

2 事件发送器发送事件到事件中心，事件中心去查找与处理该事件的监听器

```java
1 事件监听类
public  class SerialPortListener implements SerialPortEventListener {
    private DataAvailableListenerInter mDataAvailableListener;
    public SerialPortListener(DataAvailableListenerInter mDataAvailableListener) {
        this.mDataAvailableListener = mDataAvailableListener;
    }
    public void serialEvent(SerialPortEvent serialPortEvent) {
        switch (serialPortEvent.getEventType()) {
                // 有数据到达
            case SerialPortEvent.DATA_AVAILABLE:
                if (mDataAvailableListener != null) {
                    mDataAvailableListener.dataAvailable();
                }
                break;
          ...
            default:
                break;
        }
    }
}
2 将监听事件加入到串口 
serialPort.addEventListener(new SerialPortListener(listener));
3 事件执行程序，当事件发生时，执行的程序
SerialPortManager.addListener(mSerialport, new DataAvailableListenerInter() {
    @Override
    public void dataAvailable() {
        byte[] data = null;
        String serialNamePrefix = "";
        PropertiesUtil com = new PropertiesUtil("com");
        if (System.getProperty("os.name").contains("Windows")) {
            serialNamePrefix = "//./";
        }
        try {
            if (mSerialport == null) {
                ShowUtil.errorMessage("The serial port object is empty, monitoring failed!");
            } else if (mSerialport.getName().equals(serialNamePrefix + com.getUrlValue("LoraCom"))) {
                queue = SerialPortManager.readFromPort(mSerialport,queue);
                while (queue.getSize() >= 17) {
                    data = queue.dequeueNEle(17);
                    Short[] sensors = (Short[]) parseData.parseData(data);
                    double tem = sensors[0] / 10.0, hum = sensors[1] / 10.0;
                    Date d = new Date();
                    SimpleDateFormat ft = new SimpleDateFormat("yyyy-MM-dd hh:mm:ss");
                    String sDate = ft.format(d);
                    Sensor lora_sensor = new Sensor(1, tem, hum, sDate);
                    log.info("lora sensor data:" + lora_sensor.toString());
                    queueHelper.SendMessageToHandler(lora_sensor);
                }
            } else if (mSerialport.getName().equals(serialNamePrefix + com.getUrlValue("ZigbeeCom"))) {
                log.info("GateWay get the data of the zigbee end-device and start parsing");
                ...
            }
        } catch (Exception e) {
            log.info("reading serial port error  ");
            e.printStackTrace();
        }
    }
});
3.1 串口有数据可用，也就是有数据到来时，就会触发事件处理程序，事件处理程序从串口读取数据，函数如下，将数据读取出来存储至缓冲区中，
    然后从缓冲区根据协议包大小，从缓冲区取出让协议解析器处理，协议解析器处理完成之后，使传感器对象交给disruptor生产者 //SerialPortManager.readFromPort(mSerialport,queue);
 public static LinkedListQueue readFromPort(SerialPort serialPort, LinkedListQueue linkedListQueue) {
        InputStream in = null;
        try {
            in = serialPort.getInputStream();
            byte[] readBuffer = new byte[1];
            while(in.available() > 0) {
                //从in中读取一个readBuffer大小的数据的ASCII码，放在readBuffer中
                in.read(readBuffer);
                //将读取的一个字节数据的ASCII码存储到队列中
                linkedListQueue.enqueue(readBuffer[0]);
            }
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            try {
                if (in != null) {
                    in.close();
                    in = null;
                }
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
        return linkedListQueue;
    }
```

### 出现过什么问题? 

#### 出现过网络通信过程中的类似于TCP粘包问题

Zigbee 和 Lora 是根据自组网实现数据报的传输 Zigbee 每一台设备有一个地址，类似于MAC地址之类，接收器可以收到在它能力范围的数据包内容。

#### 网络通信时，如何解决粘包、丢包或者包乱序问题？

如果是在 TCP 协议，在大多数场景下，是不存在丢包和包乱序问题的，TCP 通信是可靠通信方式，TCP 协议栈通过**序列号和包重传确认**机制保证数据包和一定被正确发到目的地；如果是 UDP 协议，如果不能接收少量丢包，那就要在 UDP 的基础上实现类似 TCP 这种有序和可靠传输机制了。

#### 出现粘包的原因

TCP 协议是流式协议，即协议的内容是像流水一样的字节流，**内容与内容之间没有明确的分界标志**，需要我们人为地去给这些协议划分边界。所以TCP中容易出现几个包粘在一起，或者出现半包的情况。

在进行接收 Zigbee 和 Lora 数据包的时候，发现过有的时候会出现两个数据包结合在一起，类似于类似TCP粘包的问题

如何解决粘包问题：

所以如何解决粘包呢？

**固定数据包的包长**

将每个协议包的长度都是固定的，所以，当不够数据包长度是时，就存在缓冲区里，否则，就取出来。所以在缓冲区设置了一个缓冲队列，当队列达到包的长度是才从队列中取出一包一包的数据进行解析。

还有其它的解决粘包的方案

**以指定字符串为包的结束标志**

可以加上一些特殊的结束符，代表包的结束，比如发邮件的 SMTP 和熟悉的 FTP 协议，在一段数据后面加上”\r\n“表示一个包的结束，但是这种存在一个问题，如果发送的报的数据中包含	结束的字符，需要对这些字符进行转义操作，否则被接收方错误地当成包结束标志而误解析。

**包头+包体格式**

这种格式包头必须含有一个字段说明接下来的包体有多大。

### 为什么要使用多态实现多协议解析 ?

因为考虑到边缘网关可以继续接入更多的协议，提高程序可扩展能力，定义好需要解析协议所需要的接口，再增加新协议的时候，增加新的设备类型。在在调用解析器的时候，让接口对象动态绑定解析器解析数据。



### <font color="red">压力测试是怎么做的?</font>

调研压力测试怎么做？



### 遇到过的问题 ?

#### 数据粘包

1. 由于是物理设备，偶尔会产生无效，获得不完整的数据，导致解析就会出问题，在应用层做校验。

1. 融合异构网络的区块链溯源边缘网关

1. 串口来的数据太快, 网关来不及处理, 就会导致网关出现卡顿的现象 

// 解决办法: 设置缓冲区, 解决上传速度与处理速度不匹配问题.

### 有没有使用什么设计模式 ?

在创建 disruptor 消息的时候使用了工厂模式创建对象, 工厂模式的优点

- 面向接口编程，体现了面向对象的思想；
- 将创建对象的工作转移到了工厂类；
- 

disruptor 使用到了<strong>观察者模式</strong>

生产者拿到了消息 , 就放入ringbuff 中, 消费者发现 ringbuff 有消息, 就立马从ringbuff中取出数据, 然后消费.

每个种类的消费者依此消费一遍消息, 每一个种类的消费者创建 10 个, 用 10 个消费者去消费生产者消费的消息.

​	 

